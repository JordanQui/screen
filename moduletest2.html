<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Hydra • FM String — 5 ops (safe & flat)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#000000" />
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { position:fixed; inset:0; width:100vw; height:100vh; display:block; background:#000; }
  </style>
  <!-- Utilise le bundle complet officiel pour éviter les manques d'opérateurs -->
  <script src="https://cdn.jsdelivr.net/npm/hydra-synth/dist/hydra-synth.js"></script>
</head>
<body>
<canvas id="hydra"></canvas>
<script>
/* ===== In — 4 bandes depuis le shell (AUCUN micro ici) ===== */
let low=0, mid1=0, mid2=0, high=0;
addEventListener('message',(e)=>{
  const d=e.data; if(!d) return;
  if(d.type==='bands'){ low=d.low||0; mid1=d.mid1||0; mid2=d.mid2||0; high=d.high||0; }
});

/* ===== Hi-DPI ===== */
const canvas = document.getElementById('hydra');
function setHiRes(){
  const dpr = Math.min(3.0, window.devicePixelRatio||1);
  const w = Math.floor(innerWidth*dpr), h = Math.floor(innerHeight*dpr);
  canvas.width=w; canvas.height=h;
  if (window.hydra?.setResolution) window.hydra.setResolution(w,h);
}
setHiRes();
const hydra = new Hydra({ canvas, detectAudio:false, width:canvas.width, height:canvas.height, pixelRatio:1 });
window.hydra = hydra;
addEventListener('resize', setHiRes);

/* ===== Aliases & helpers ===== */
const L  = () => low;
const M1 = () => mid1;
const M2 = () => mid2;
const Hh = () => high;
const Hsoft = () => Math.pow(Hh(), 0.72); // plafonne les aigus

/* ===== Fréquences (douces, proches de ton boiler) ===== */
const fLow  = () =>  8.0 + L()*20 + (L()*2.0)*Math.sin(time*1.11);
const fM1   = () => 10.5 + M1()* 8 + (M1()*1.7)*Math.sin(time*1.33);
const fM2   = () => 14.0 + M2()*10 + (M2()*2.0)*Math.sin(time*1.55);
const fHigh = () => Math.min(18 + Hsoft()*28 + (Hsoft()*2.4)*Math.sin(time*2.30), 34);
const fC5   = () => Math.max(5.5, fLow()*0.72 + (L()*1.6 + (M1()+M2())*0.8)*0.5); // Sub “sympathetic”

/* ===== Indices courts (on garde le shader compact) ===== */
const I_C1_M1 = () => 0.020 + M1()*0.18;  // M1 → C1
const I_C1_M2 = () => 0.010 + M2()*0.10;  // M2 → C1
const I_C3_M1 = () => 0.010 + M1()*0.12;  // M1 → C3
const I_C4_M2 = () => 0.010 + M2()*0.12;  // M2 → C4
const I_C4_NO = () => 0.006 + Hsoft()*0.05; // bruit fin → C4
const I_C5_M1 = () => 0.008 + M1()*0.10;  // M1 → C5
const I_C5_M2 = () => 0.008 + M2()*0.10;  // M2 → C5

/* ===== Masque “corde” (bande horizontale fine) ===== */
const stringMask = shape(4, 0.5, 0.001).scale(2.0, 0.06); // large X, fin Y

/* ===== Patch FLAT (une seule passe de synthèse + post + feedback) ===== */
function buildPatch(){
  // Modulateurs simples (nodes, pas de buffers)
  const m1 = osc(fM1, 0, 0);
  const m2 = osc(fM2, 0, 0);

  // 5 opérateurs très peu imbriqués
  const C1 = osc(fLow, 0, 0)
    .modulate(m1, I_C1_M1)
    .modulate(m2, I_C1_M2)
    .mult(stringMask)
    .color(() => 0.12 + L()*0.88, 0, 0); // rouge idle

  const C2 = osc(fM1, 0, 0)
    .mult(stringMask)
    .color(0, () => 0.18 + M1()*0.82, 0);

  const C3 = osc(fM2, 0, 0)
    .modulate(m1, I_C3_M1)
    .mult(stringMask)
    .color(0, 0, () => 0.18 + M2()*0.82);

  const C4 = osc(fHigh, 0, 0)
    .modulate(m2, I_C4_M2)
    .modulate(noise(2.3, 0.22), I_C4_NO)
    .mult(stringMask)
    .color(
      () => 0.08 + Math.min(1.00, Hsoft()*1.05),
      () => 0.08 + Math.min(1.00, Hsoft()*1.05),
      () => 0.08 + Math.min(1.00, Hsoft()*1.05)
    );

  const C5 = osc(fC5, 0, 0)
    .modulate(m1, I_C5_M1)
    .modulate(m2, I_C5_M2)
    .mult(stringMask)
    .color(() => 0.08 + L()*0.70, 0, 0); // rouge sombre (sub)

  // Pluck (léger) inline
  const strike = shape(4, 0.20, 0.001)
    .scale(1.4, 1.0)
    .scrollX(() => Math.sin(time*0.18)*0.30 + (M2()-L())*0.10);

  const pluck = noise(
      () => 1.1 + Hsoft()*6.0,
      () => 0.10 + Hsoft()*0.40
    )
    .thresh(() => 0.72 - Math.min(0.6, Hsoft()*0.52))
    .luma(() => 0.50 + (1.0 - Hsoft())*0.25)
    .brightness(() => 0.06 + Hsoft()*0.55)
    .contrast(1.04)
    .color(
      () => 0.35 + Hsoft()*0.60,
      () => 0.35 + Hsoft()*0.60,
      () => 0.35 + Hsoft()*0.60
    )
    .mult(strike)
    .modulate(osc(3.0, 0, 0), () => 0.02 + Hsoft()*0.05);

  // Somme FLAT (aucun src(oX) pendant la somme → pas de cycles)
  let comp = C1.add(C2,0.95).add(C3,0.95).add(C4,0.90).add(C5,0.85).add(pluck, () => 0.30 + Hsoft()*0.30)
    .saturate(1.02).contrast(1.012);

  // Flow anti-pixel (léger)
  const flow = noise(
    () => 1.22 + (M1()+M2()+Hh())*1.9,
    () => 0.05  + Hh()*0.36
  );
  comp = comp.modulate(flow, () => 0.008 + (L()+M1()+M2())*0.014 + Hsoft()*0.022);

  // Feedback PROPRE: lit uniquement l'image précédente de o0
  const fbAmt = () => Math.min(0.34, 0.12 + (L()+M1()+M2())*0.18 + Hsoft()*0.14);
  comp.blend(
    src(o0).colorama(() => 0.008 + Hh()*0.032).contrast(1.001),
    fbAmt
  ).out(o0);
}
buildPatch();
render(o0);

/* ===== Ping “paint-hot” au shell (utile pour ton orchestrateur) ===== */
requestAnimationFrame(()=> parent.postMessage({type:'paint-hot'}, '*'));
</script>
</body>
</html>

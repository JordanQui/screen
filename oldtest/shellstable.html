<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Hydra Shell — instant swap + mic reset 4min + raw mic + sensitivity</title>
  <meta name="theme-color" content="#000000">
  <style>
    html,body { margin:0; height:100%; background:#000; overflow:hidden; }
    .stack { position:fixed; inset:0; display:grid; place-items:stretch; background:#000; }
    .layer {
      grid-area:1/1; border:0; width:100%; height:100%;
      background:#000;                 /* jamais de blanc */
      z-index:1;                       /* 2 pour l’iframe au-dessus */
    }
    #hud {
      position:fixed; left:8px; bottom:8px; color:#0f0;
      font:12px ui-monospace, Menlo, Consolas, monospace;
      background:#000a; padding:6px 8px; border-radius:6px; white-space:pre;
      pointer-events:none;
    }
  </style>
</head>
<body>
  <div class="stack">
    <iframe id="frameA" class="layer" allow="autoplay"></iframe>
    <iframe id="frameB" class="layer" allow="autoplay"></iframe>
  </div>
  <!-- Décommente si tu veux l’état à l’écran :
  <div id="hud">init…</div>
  -->

  <script>
  /* ===== Réglages ===== */
  const APP_URL        = 'module1.html';
  const SWAP_EVERY_MS  = 888000;        // cadence de swap
  const HOT_TIMEOUT    = 3000;          // attente max du “paint-hot”
  const FFT_SIZE       = 256;

  // Sensibilité / seuil
  const SENS_GAIN      = 3.0;           // <<< BOOST d'entrée (1.0 = neutre, 2.0–4.0 = +sensibilité)
  const THRESH         = 0.003;         // seuil doux (note tenue = tenue, mais sensible bas niveau)

  const MIC_RESET_MS   = 240000;        // reset micro toutes les 4 minutes

  const A   = document.getElementById('frameA');
  const B   = document.getElementById('frameB');
  const hud = document.getElementById('hud');

  let front = A;  // au-dessus (z=2)
  let back  = B;  // dessous  (z=1)
  let cycle = 0;
  let micRestarts = 0;

  function setTop(frm){ frm.style.zIndex = '2'; }
  function setBottom(frm){ frm.style.zIndex = '1'; }
  function hudMsg(extra=''){
    if (!hud) return;
    hud.textContent =
`front: ${front.id} (z=${front.style.zIndex||'2'})
back : ${back.id}  (z=${back.style.zIndex||'1'})
cycle: ${cycle}
mic restarts: ${micRestarts}${extra? '\n'+extra : ''}`;
  }

  /* ===== Audio côté shell (unique) ===== */
  let audioCtx, analyser, data, rafBands, streamRef, preGain;
  let micResetTimerId = null, micRestarting = false;

  async function startAudio(){
    try{
      const constraints = {
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
          googEchoCancellation: false,
          googNoiseSuppression: false,
          googAutoGainControl: false,
          channelCount: 1,
          latency: 0,
          sampleRate: 48000,
          sampleSize: 16
        },
        video: false
      };

      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      const track = stream.getAudioTracks()[0];
      if (track && track.applyConstraints) {
        try {
          await track.applyConstraints({
            advanced: [{
              echoCancellation: false,
              noiseSuppression: false,
              autoGainControl: false
            }]
          });
        } catch {}
      }

      streamRef = stream;

      audioCtx  = new (window.AudioContext||window.webkitAudioContext)();
      const src = audioCtx.createMediaStreamSource(stream);

      // <<< Gain d'entrée pour augmenter la sensibilité
      preGain = audioCtx.createGain();
      preGain.gain.value = SENS_GAIN;

      analyser  = audioCtx.createAnalyser();
      analyser.fftSize = FFT_SIZE;

      /* Réglages pour “tenir” une note soutenue sans dérive,
         mais capter des signaux faibles */
      analyser.smoothingTimeConstant = 0.12;
      analyser.minDecibels = -100;   // plus bas → plus de détail bas niveau
      analyser.maxDecibels = -10;

      // Chaînage: micro -> preGain (boost) -> analyser
      src.connect(preGain);
      preGain.connect(analyser);

      data = new Uint8Array(analyser.frequencyBinCount);

      const avg=(s,e)=>{ let S=0; for(let i=s;i<=e;i++) S+=data[i]; return (S/(e-s+1))/255; };

      const tick=()=>{
        if (audioCtx.state==='suspended') audioCtx.resume().catch(()=>{});
        analyser.getByteFrequencyData(data);
        const n=data.length, q1=Math.floor(n*0.25)-1, q2=Math.floor(n*0.5)-1, q3=Math.floor(n*0.75)-1;

        const lowRaw  = avg(0, q1);
        const m1Raw   = avg(q1+1, q2);
        const m2Raw   = avg(q2+1, q3);
        const highRaw = avg(q3+1, n-1);

        // Seuillage doux (pas de soustraction qui “grignote” la tenue)
        const low  = lowRaw  < THRESH ? 0 : lowRaw;
        const m1   = m1Raw   < THRESH ? 0 : m1Raw;
        const m2   = m2Raw   < THRESH ? 0 : m2Raw;
        const high = highRaw < THRESH ? 0 : highRaw;

        const payload={type:'bands',low,mid1:m1,mid2:m2,high};
        front.contentWindow?.postMessage(payload,'*');
        back .contentWindow?.postMessage(payload,'*');

        rafBands = requestAnimationFrame(tick);
      };
      rafBands = requestAnimationFrame(tick);

      startMicResetTimer(); // (re)démarre le reset périodique 4 min
    }catch(e){ /* silencieux */ }
  }

  function stopAudio(){
    if (rafBands) cancelAnimationFrame(rafBands), rafBands=null;
    if (analyser) { try{ analyser.disconnect(); }catch{} }
    if (preGain)  { try{ preGain.disconnect(); }catch{} }
    if (audioCtx && audioCtx.state!=='closed') { try{ audioCtx.close(); }catch{} }
    if (streamRef){ try{ streamRef.getTracks().forEach(t=>t.stop()); }catch{} }
    audioCtx=analyser=preGain=data=streamRef=null;
  }

  async function restartAudio(){
    if (micRestarting) return;          // anti-réentrance
    micRestarting = true;
    stopAudio();
    micRestarts++;
    hudMsg();
    await startAudio();
    micRestarting = false;
  }

  function startMicResetTimer(){
    if (micResetTimerId) clearInterval(micResetTimerId);
    micResetTimerId = setInterval(restartAudio, MIC_RESET_MS);
  }

  /* ===== Précharge (reload caché) + attente "paint-hot" ===== */
  function preloadAndHeat(frm){
    return new Promise((resolve)=>{
      let hot = false;
      const t = setTimeout(()=>{
        if (!hot){ cleanup(); resolve(false); }
      }, HOT_TIMEOUT);

      function onMsg(e){
        if (e.source!==frm.contentWindow) return;
        if (e.data?.type==='paint-hot'){
          hot = true; cleanup(); resolve(true);
        }
      }
      function cleanup(){ clearTimeout(t); window.removeEventListener('message', onMsg); }

      window.addEventListener('message', onMsg);
      setBottom(frm);
      frm.src = APP_URL;
    });
  }

  /* ===== Switch instantané (z-index only) ===== */
  async function instantSwapToBack(){
    setTop(back);
    setBottom(front);
    [front, back] = [back, front];
    hudMsg('swap OK');
  }

  /* ===== Cycle ===== */
  async function runCycle(){
    cycle++; hudMsg(`cycle #${cycle}`);
    await preloadAndHeat(back);     // prépare dessous
    await instantSwapToBack();      // switch instantané au-dessus
    await preloadAndHeat(back);     // prépare l’ancienne (dessous) pour la prochaine passe
  }

  /* ===== Boot + boucle ===== */
  async function start(){
    await startAudio();
    await preloadAndHeat(A); setTop(A); setBottom(B); hudMsg('boot → A visible');
    await preloadAndHeat(B);
    runCycle();
    setInterval(runCycle, SWAP_EVERY_MS);
  }

  start();
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Hydra • Module — bands from shell • sharp + dezoom + fb clean</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#000000" />
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { position:fixed; inset:0; width:100vw; height:100vh; display:block; background:#000; }
  </style>
  <script src="/hydra/hydra.js"></script>
</head>
<body>
<canvas id="hydra"></canvas>
<script>
/* ===== Réception bandes ===== */
let low=0, mid1=0, mid2=0, high=0;
addEventListener('message',(e)=>{
  const d=e.data; if(!d) return;
  if(d.type==='bands'){ low=d.low||0; mid1=d.mid1||0; mid2=d.mid2||0; high=d.high||0; }
  if(d.type==='setParams'){ applyParams(d.params||{}); }
});

/* ===== Paramètres exposés ===== */
const P = {
  color: { low:"#ff1a1a", m1:"#18ff66", m2:"#1aa3ff", hi:"#ffffff" },
  fm:    { low:1.0, m1:1.0, m2:1.0, hi:1.0 },
  flow:  { scale:0.18, speed:0.95, amt:3.20 },   // -20% d’amplitude pour réduire l’aspect “blob”
  nHi:   { scale:0.60, speed:0.95, mix:0.00 },   // bruit des aigus un peu plus fin
  view:  { zoom:0.92 },                          // <1.0 = léger dézoom (plus de finesse perçue)
  detail:{ mul:1.12 },                           // >1.0 = motifs plus fins sans zoomer
  perf:  {
    targetFPS: 60, minFPS: 48, maxFPS: 64,
    resScale: 1.15, minScale: 1.00, maxScale: 1.40,  // jamais en-dessous du natif; léger SS par défaut
    maxDPR: 3.0, quality: 2,
    adaptEveryMs: 900, scaleStep: 0.05,
    bootLockMs: 1200
  }
};
window.P = P;

/* ===== API publique ===== */
function applyParams(p){
  if(!p) return;
  if(p.color) Object.assign(P.color, p.color);
  if(p.fm)    Object.assign(P.fm,    p.fm);
  if(p.flow)  Object.assign(P.flow,  p.flow);
  if(p.nHi)   Object.assign(P.nHi,   p.nHi);
  if(p.view)  Object.assign(P.view,  p.view);
  if(p.detail)Object.assign(P.detail,p.detail);
  if(p.perf){
    const old = {...P.perf};
    Object.assign(P.perf, p.perf);
    if ((p.perf.resScale!==undefined && p.perf.resScale!==old.resScale) ||
        (p.perf.maxDPR  !==undefined && p.perf.maxDPR  !==old.maxDPR)) {
      setRes(true);
    }
  }
}
window.Synth = {
  setColors: (o)=>applyParams({color:o}),
  setFM:     (o)=>applyParams({fm:o}),
  setFlow:   (o)=>applyParams({flow:o}),
  setHiNoise:(o)=>applyParams({nHi:o}),
  setView:   (o)=>applyParams({view:o}),
  setDetail: (o)=>applyParams({detail:o}),
  setPerf:   (o)=>applyParams({perf:o}),
  getParams: ()=>JSON.parse(JSON.stringify(P)),
  setParams: (o)=>applyParams(o)
};

/* ===== Hi-DPI ===== */
const canvas = document.getElementById('hydra');
function dprLimited(){ return Math.min(P.perf.maxDPR, window.devicePixelRatio||1); }
function physicalSize(){
  const s = P.perf.resScale * dprLimited();
  return [ Math.floor(innerWidth*s), Math.floor(innerHeight*s) ];
}
const [w0,h0] = physicalSize();
const hydra = new Hydra({ canvas, detectAudio:false, width:w0, height:h0, pixelRatio:1 });
window.hydra = hydra;
canvas.style.imageRendering = 'auto';

let _lastSetRes = 0;
const SETRES_DEBOUNCE_MS = 400;
function setRes(raw=false){
  const [w,h] = physicalSize();
  if (canvas.width===w && canvas.height===h) return;
  const now = performance.now();
  if (!raw && (now - _lastSetRes) < SETRES_DEBOUNCE_MS) return;
  _lastSetRes = now;
  canvas.width=w; canvas.height=h;
  hydra?.setResolution?.(w,h);
}
let _lastDPR = dprLimited();
setInterval(()=>{
  const dpr = dprLimited();
  if (Math.abs(dpr - _lastDPR) > 0.02) { _lastDPR = dpr; setRes(true); }
}, 500);
let _resizeTimer=null;
addEventListener('resize', ()=>{
  clearTimeout(_resizeTimer);
  _resizeTimer = setTimeout(()=> setRes(true), 120);
});

/* ===== Aliases ===== */
const L  = () => low;
const M1 = () => mid1;
const M2 = () => mid2;
const Hh = () => high;
const clamp01 = (v)=>Math.min(1, Math.max(0, v));

/* ===== fbm (selon qualité perf) ===== */
function fbmNoise(scaleFn, speedFn){
  const n1 = noise(scaleFn, speedFn);
  if (P.perf.quality<=1) return n1;
  const n2 = noise(()=>scaleFn()*2.07, ()=>speedFn()*1.31);
  if (P.perf.quality===2){
    const n3 = noise(()=>scaleFn()*4.19, ()=>speedFn()*1.73);
    return n1.add(n2,0.5).add(n3,0.25);
  }
  return n1.add(n2,0.5);
}

/* ===== Warm-up gate ===== */
let _warmGate = 0;
(function warmup(){
  let frames = 0;
  function step(){ frames++; if (frames>=2) _warmGate = 1; else requestAnimationFrame(step); }
  requestAnimationFrame(step);
})();

/* ===== Patch visuel ===== */
function buildPatch(){
  const Hsoft = () => Math.pow(clamp01(Hh()), 0.72);
  const D = () => P.detail.mul; // finesse des motifs

  const fLow  = () => D()*( 8 + (L()*22 * P.fm.low) + (L()*3.0*P.fm.low)*(Math.sin(time*0.90)+Math.sin(time*1.457))*0.5 );
  const fM1   = () => D()*(11 + (M1()* 8 * P.fm.m1 ) + (M1()*2.4*P.fm.m1 )*(Math.sin(time*1.00)+Math.sin(time*1.618))*0.5);
  const fM2   = () => D()*(15 + (M2()*10 * P.fm.m2 ) + (M2()*2.8*P.fm.m2 )*(Math.sin(time*1.20)+Math.sin(time*1.946))*0.5);
  const fHigh = () => D()*Math.min(18 + (Hsoft()*28*P.fm.hi) + (Hsoft()*3.2*P.fm.hi)*(Math.sin(time*1.9)+Math.sin(time*2.89))*0.5, 34);

  const red   = osc(fLow,  0, 0).color(() => (0.12+L()*0.88), 0, 0);
  const green = osc(fM1,   0, 0).color(0, () => (0.18+M1()*0.82), 0);
  const blue  = osc(fM2,   0, 0).color(0, 0, () => (0.18+M2()*0.82));

  const fbm = fbmNoise(
    () => (1.2 + Hsoft()*6.5)*P.nHi.scale,
    () => (0.11 + Hsoft()*0.40)*P.nHi.speed
  );
  const white = osc(fHigh, 0, 0)
    .modulate(fbm, () => (0.010+Hsoft()*0.040)*P.nHi.mix) // -20% pour éviter le grain carré
    .color(
      () => 0.12 + Math.min(1.0, Hsoft()*1.10),
      () => 0.12 + Math.min(1.0, Hsoft()*1.10),
      () => 0.12 + Math.min(1.0, Hsoft()*1.10)
    );

  let mix = red.add(green,0.95).add(blue,0.95).add(white,0.95)
               .saturate(1.01).contrast(1.005)
               .scale(() => P.view.zoom); // dézoom léger

  // FLOW adouci (↓) pour limiter les artefacts en feedback
  const flow = noise(
    () => (1.25+(M1()+M2()+Hh())*2.2)*P.flow.scale,
    () => (0.05+Hh()*0.40)*P.flow.speed * _warmGate
  );
  const flowAmt = () => (0.010+(L()+M1()+M2())*0.015+Hsoft()*0.026) * P.flow.amt * _warmGate;

  mix = mix.modulate(flow, flowAmt)
           .scrollX(() => (M2()-L())*0.0022)  // scroll plus fin
           .scrollY(() => (M1()-Hh())*0.0022);

  // Feedback plus “propre” : plafond ↓, micro-contrast ↓ pour éviter les blocs
  const fbAmtBase = () => Math.min(0.22, 0.10+(L()+M1()+M2())*0.14+Hsoft()*0.10);
  const fbAmt = () => fbAmtBase() * _warmGate;

  mix = mix.blend(
    src(o0)
      .colorama(() => 0.006+Hh()*0.020)  // -40%
      .contrast(1.0005),                 // micro-ajustement
    fbAmt
  ).out(o0);
}
buildPatch();
render(o0);

/* ===== Perf monitor (qualité d’abord, jamais < natif) ===== */
let _frames=0, _lastT=performance.now(), _accMs=0, _lastAdapt=performance.now();
const _bootT0 = performance.now();
function perfTick(now){
  _frames++;
  const dt = now - _lastT; _lastT = now; _accMs += dt;
  if (_accMs >= 500){
    const fps = (_frames * 1000) / _accMs;
    _frames=0; _accMs=0;
    if (performance.now() - _bootT0 >= P.perf.bootLockMs){
      const t=performance.now();
      if (t-_lastAdapt >= P.perf.adaptEveryMs){
        _lastAdapt=t;
        if (fps < P.perf.minFPS){
          if (P.perf.quality>1) P.perf.quality=1;
          else if (fps < P.perf.minFPS-8 && P.perf.resScale>1.00){
            P.perf.resScale=Math.max(1.00, P.perf.resScale-P.perf.scaleStep); setRes(true);
          } else if (P.perf.resScale>1.00){
            P.perf.resScale=Math.max(1.00, P.perf.resScale-P.perf.scaleStep); setRes(true);
          }
        } else if (fps > P.perf.maxFPS){
          if (P.perf.resScale<P.perf.maxScale){
            P.perf.resScale=Math.min(P.perf.maxScale,P.perf.resScale+P.perf.scaleStep); setRes(true);
          } else if (P.perf.quality<2){ P.perf.quality=2; }
        }
      }
    }
  }
  requestAnimationFrame(perfTick);
}
requestAnimationFrame(perfTick);

/* ===== “paint-hot” après 2 frames pleines ===== */
let _paintFrames=0;
function paintPing(){
  _paintFrames++;
  if (_paintFrames>=2) parent.postMessage({type:'paint-hot'}, '*');
  else requestAnimationFrame(paintPing);
}
requestAnimationFrame(paintPing);
</script>
</body>
</html>

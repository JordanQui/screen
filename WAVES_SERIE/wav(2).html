<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Hydra • Module — bands from shell • sharp + dezoom + fb clean • palette néon</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#000000" />
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { position:fixed; inset:0; width:100vw; height:100vh; display:block; background:#000; }
  </style>
  <script src="/hydra/hydra.js"></script>
</head>
<body>
<canvas id="hydra"></canvas>
<script>
/* ===== Réception bandes ===== */
let low=0, mid1=0, mid2=0, high=0;
addEventListener('message',(e)=>{
  const d=e.data; if(!d) return;
  if(d.type==='bands'){ low=d.low||0; mid1=d.mid1||0; mid2=d.mid2||0; high=d.high||0; }
  if(d.type==='setParams'){ applyParams(d.params||{}); }
});

/* ===== Paramètres exposés (nouvelle palette) ===== */
const P = {
  color: { 
    low:"#ff6b00",   // ambre
    m1:"#00ffd0",    // aqua
    m2:"#7a5cff",    // violet
    hi:"#ffd54a"     // or doux (remplace le blanc dur)
  },
  fm:    { low:1.0, m1:1.0, m2:1.0, hi:1.0 },
  flow:  { scale:0.18, speed:0.95, amt:3.20 },
  nHi:   { scale:0.60, speed:0.95, mix:0.00 },
  view:  { zoom:0.92 },
  detail:{ mul:1.12 },
  perf:  {
    targetFPS: 60, minFPS: 48, maxFPS: 64,
    resScale: 1.15, minScale: 1.00, maxScale: 1.40,
    maxDPR: 3.0, quality: 2,
    adaptEveryMs: 900, scaleStep: 0.05,
    bootLockMs: 1200
  },
  _col: { low:[1,0,0], m1:[0,1,0], m2:[0,0,1], hi:[1,1,1] } // compilé depuis hex
};
function hexToF3(hex){
  const h = (hex||"#000").replace("#","").trim();
  const n = h.length===3 ? h.split("").map(c=>c+c).join("") : h;
  const r = parseInt(n.slice(0,2),16)/255;
  const g = parseInt(n.slice(2,4),16)/255;
  const b = parseInt(n.slice(4,6),16)/255;
  return [r,g,b];
}
function compilePalette(){
  P._col.low = hexToF3(P.color.low);
  P._col.m1  = hexToF3(P.color.m1);
  P._col.m2  = hexToF3(P.color.m2);
  P._col.hi  = hexToF3(P.color.hi);
}
compilePalette();
window.P = P;

/* ===== API publique ===== */
function applyParams(p){
  if(!p) return;
  if(p.color){ Object.assign(P.color, p.color); compilePalette(); }
  if(p.fm)    Object.assign(P.fm,    p.fm);
  if(p.flow)  Object.assign(P.flow,  p.flow);
  if(p.nHi)   Object.assign(P.nHi,   p.nHi);
  if(p.view)  Object.assign(P.view,  p.view);
  if(p.detail)Object.assign(P.detail,p.detail);
  if(p.perf){
    const old = {...P.perf};
    Object.assign(P.perf, p.perf);
    if ((p.perf.resScale!==undefined && p.perf.resScale!==old.resScale) ||
        (p.perf.maxDPR  !==undefined && p.perf.maxDPR  !==old.maxDPR)) {
      setRes(true);
    }
  }
}
window.Synth = {
  setColors: (o)=>applyParams({color:o}),
  setFM:     (o)=>applyParams({fm:o}),
  setFlow:   (o)=>applyParams({flow:o}),
  setHiNoise:(o)=>applyParams({nHi:o}),
  setView:   (o)=>applyParams({view:o}),
  setDetail: (o)=>applyParams({detail:o}),
  setPerf:   (o)=>applyParams({perf:o}),
  getParams: ()=>JSON.parse(JSON.stringify(P)),
  setParams: (o)=>applyParams(o)
};

/* ===== Hi-DPI ===== */
const canvas = document.getElementById('hydra');
function dprLimited(){ return Math.min(P.perf.maxDPR, window.devicePixelRatio||1); }
function physicalSize(){
  const s = P.perf.resScale * dprLimited();
  return [ Math.floor(innerWidth*s), Math.floor(innerHeight*s) ];
}
const [w0,h0] = physicalSize();
const hydra = new Hydra({ canvas, detectAudio:false, width:w0, height:h0, pixelRatio:1 });
window.hydra = hydra;
canvas.style.imageRendering = 'auto';

let _lastSetRes = 0;
const SETRES_DEBOUNCE_MS = 400;
function setRes(raw=false){
  const [w,h] = physicalSize();
  if (canvas.width===w && canvas.height===h) return;
  const now = performance.now();
  if (!raw && (now - _lastSetRes) < SETRES_DEBOUNCE_MS) return;
  _lastSetRes = now;
  canvas.width=w; canvas.height=h;
  hydra?.setResolution?.(w,h);
}
let _lastDPR = dprLimited();
setInterval(()=>{
  const dpr = dprLimited();
  if (Math.abs(dpr - _lastDPR) > 0.02) { _lastDPR = dpr; setRes(true); }
}, 500);
let _resizeTimer=null;
addEventListener('resize', ()=>{
  clearTimeout(_resizeTimer);
  _resizeTimer = setTimeout(()=> setRes(true), 120);
});

/* ===== Aliases ===== */
const L  = () => low;
const M1 = () => mid1;
const M2 = () => mid2;
const Hh = () => high;
const clamp01 = (v)=>Math.min(1, Math.max(0, v));

/* ===== fbm (selon qualité perf) ===== */
function fbmNoise(scaleFn, speedFn){
  const n1 = noise(scaleFn, speedFn);
  if (P.perf.quality<=1) return n1;
  const n2 = noise(()=>scaleFn()*2.07, ()=>speedFn()*1.31);
  if (P.perf.quality===2){
    const n3 = noise(()=>scaleFn()*4.19, ()=>speedFn()*1.73);
    return n1.add(n2,0.5).add(n3,0.25);
  }
  return n1.add(n2,0.5);
}

/* ===== Warm-up gate ===== */
let _warmGate = 0;
(function warmup(){
  let frames = 0;
  function step(){ frames++; if (frames>=2) _warmGate = 1; else requestAnimationFrame(step); }
  requestAnimationFrame(step);
})();

/* ===== Patch visuel (avec palette appliquée) ===== */
function buildPatch(){
  const Hsoft = () => Math.pow(clamp01(Hh()), 0.72);
  const D = () => P.detail.mul;

  const fLow  = () => D()*( 8 + (L()*22 * P.fm.low) + (L()*3.0*P.fm.low)*(Math.sin(time*0.90)+Math.sin(time*1.457))*0.5 );
  const fM1   = () => D()*(11 + (M1()* 8 * P.fm.m1 ) + (M1()*2.4*P.fm.m1 )*(Math.sin(time*1.00)+Math.sin(time*1.618))*0.5);
  const fM2   = () => D()*(15 + (M2()*10 * P.fm.m2 ) + (M2()*2.8*P.fm.m2 )*(Math.sin(time*1.20)+Math.sin(time*1.946))*0.5);
  const fHigh = () => D()*Math.min(18 + (Hsoft()*28*P.fm.hi) + (Hsoft()*3.2*P.fm.hi)*(Math.sin(time*1.9)+Math.sin(time*2.89))*0.5, 34);

  // helpers couleur
  const colLow = ()=>P._col.low, colM1=()=>P._col.m1, colM2=()=>P._col.m2, colHi=()=>P._col.hi;

  const baseLow  = () => (0.12+L()*0.88);
  const baseM1   = () => (0.18+M1()*0.82);
  const baseM2   = () => (0.18+M2()*0.82);
  const baseHigh = () => (0.12+Math.min(1.0, Hsoft()*1.10));

  const lowL = osc(fLow, 0, 0).color(
    ()=> baseLow()*colLow()[0], ()=> baseLow()*colLow()[1], ()=> baseLow()*colLow()[2]
  );
  const m1L  = osc(fM1,  0, 0).color(
    ()=> baseM1()*colM1()[0],  ()=> baseM1()*colM1()[1],  ()=> baseM1()*colM1()[2]
  );
  const m2L  = osc(fM2,  0, 0).color(
    ()=> baseM2()*colM2()[0],  ()=> baseM2()*colM2()[1],  ()=> baseM2()*colM2()[2]
  );

  const fbm = fbmNoise(
    () => (1.2 + Hsoft()*6.5)*P.nHi.scale,
    () => (0.11 + Hsoft()*0.40)*P.nHi.speed
  );
  const hiL = osc(fHigh, 0, 0)
    .modulate(fbm, () => (0.010+Hsoft()*0.040)*P.nHi.mix)
    .color(
      ()=> baseHigh()*colHi()[0],
      ()=> baseHigh()*colHi()[1],
      ()=> baseHigh()*colHi()[2]
    );

  let mix = lowL.add(m1L,0.95).add(m2L,0.95).add(hiL,0.95)
               .saturate(1.01).contrast(1.005)
               .scale(() => P.view.zoom);

  const flow = noise(
    () => (1.25+(M1()+M2()+Hh())*2.2)*P.flow.scale,
    () => (0.05+Hh()*0.40)*P.flow.speed * _warmGate
  );
  const flowAmt = () => (0.010+(L()+M1()+M2())*0.015+Hsoft()*0.026) * P.flow.amt * _warmGate;

  mix = mix.modulate(flow, flowAmt)
           .scrollX(() => (M2()-L())*0.0022)
           .scrollY(() => (M1()-Hh())*0.0022);

  const fbAmtBase = () => Math.min(0.22, 0.10+(L()+M1()+M2())*0.14+Hsoft()*0.10);
  const fbAmt = () => fbAmtBase() * _warmGate;

  mix = mix.blend(
    src(o0)
      .colorama(() => 0.006+Hh()*0.020)
      .contrast(1.0005),
      
    fbAmt
  )
  .out(o0);
}
buildPatch();
render(o0);

/* ===== Perf monitor ===== */
let _frames=0, _lastT=performance.now(), _accMs=0, _lastAdapt=performance.now();
const _bootT0 = performance.now();
function perfTick(now){
  _frames++;
  const dt = now - _lastT; _lastT = now; _accMs += dt;
  if (_accMs >= 500){
    const fps = (_frames * 1000) / _accMs;
    _frames=0; _accMs=0;
    if (performance.now() - _bootT0 >= P.perf.bootLockMs){
      const t=performance.now();
      if (t-_lastAdapt >= P.perf.adaptEveryMs){
        _lastAdapt=t;
        if (fps < P.perf.minFPS){
          if (P.perf.quality>1) P.perf.quality=1;
          else if (fps < P.perf.minFPS-8 && P.perf.resScale>1.00){
            P.perf.resScale=Math.max(1.00, P.perf.resScale-P.perf.scaleStep); setRes(true);
          } else if (P.perf.resScale>1.00){
            P.perf.resScale=Math.max(1.00, P.perf.resScale-P.perf.scaleStep); setRes(true);
          }
        } else if (fps > P.perf.maxFPS){
          if (P.perf.resScale<P.perf.maxScale){
            P.perf.resScale=Math.min(P.perf.maxScale,P.perf.resScale+P.perf.scaleStep); setRes(true);
          } else if (P.perf.quality<2){ P.perf.quality=2; }
        }
      }
    }
  }
  requestAnimationFrame(perfTick);
}
requestAnimationFrame(perfTick);

/* ===== “paint-hot” ===== */
let _paintFrames=0;
function paintPing(){
  _paintFrames++;
  if (_paintFrames>=2) parent.postMessage({type:'paint-hot'}, '*');
  else requestAnimationFrame(paintPing);
}
requestAnimationFrame(paintPing);
</script>
</body>
</html>

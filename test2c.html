<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Hydra — Genèse du son (Multi-rings, vibration spectrale)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden}
    #hydra{width:100vw;height:100vh;display:block}
  </style>
  <script src="https://unpkg.com/hydra-synth"></script>
</head>
<body>
  <canvas id="hydra"></canvas>
  <script>
    /* ========= Réception depuis le shell  ========= */
    const bands = { low:0, mid1:0, mid2:0, high:0 };
    window.addEventListener('message',(e)=>{
      const d=e.data;
      if(!d || d.type!=='bands') return;
      bands.low  = clamp01(d.low  ?? 0);
      bands.mid1 = clamp01(d.mid1 ?? 0);
      bands.mid2 = clamp01(d.mid2 ?? 0);
      bands.high = clamp01(d.high ?? 0);
      lastBandT = performance.now();
    });
    const clamp01 = x => x<0?0:x>1?1:x;

    /* ========= Enveloppes dynamiques ========= */
    let lastBandT=performance.now();
    let breath=0,resonance=0;
    let colorWarm=0,colorGreen=0,colorBlue=0,shimmer=0;

    function updateEnvelopes(){
      const stale = (performance.now()-lastBandT)>250;
      const l = stale?0:bands.low;
      const m1= stale?0:bands.mid1;
      const m2= stale?0:bands.mid2;
      const h = stale?0:bands.high;

      const targetBreath = Math.max(l,m1,m2,h);
      breath    += (targetBreath-breath)    * (targetBreath>breath ? 0.50 : 0.15);
      resonance += (targetBreath-resonance) * (targetBreath>resonance? 0.10 : 0.035);

      colorWarm += (l  - colorWarm) * 0.05;   // L
      colorGreen+= (m1 - colorGreen)* 0.40;   // M1
      colorBlue += (m2 - colorBlue) * 0.40;   // M2
      shimmer   += (h  - shimmer * 2);   // H

      requestAnimationFrame(updateEnvelopes);
    }

    /* ========= Hydra ========= */
    const hydra=new Hydra({
      canvas:document.getElementById('hydra'),
      makeGlobal:true,
      detectAudio:false
    });

    // Helpers exposés à Hydra
    window.$breath    = ()=>breath;
    window.$resonance = ()=>resonance;
    window.$L = ()=>colorWarm;
    window.$M1= ()=>colorGreen;
    window.$M2= ()=>colorBlue;
    window.$H = ()=>shimmer;

    // Courbes gaussiennes pour interpolation spectrale
    function bell(x,c,w){ const k=(x-c)/w; return Math.exp(-0.5*k*k); }
    function specAt(x){
      const cL=0.10, cM1=0.35, cM2=0.65, cH=0.90;
      const wL=0.22, wM1=0.20, wM2=0.20, wH=0.22;
      const bL=bell(x,cL,wL), b1=bell(x,cM1,wM1), b2=bell(x,cM2,wM2), bH=bell(x,cH,wH);
      const num=bL*$L()+b1*$M1()+b2*$M2()+bH*$H();
      const den=bL+b1+b2+bH+1e-6;
      return num/den;
    }

    /* ---- MULTI-ANNEAUX : sans multiplication, juste vibration du bruit ---- */
    function ringsMulti(n=9){
      const fMin = 0.6, fMax = 12.0;
      const spdMin = 0.02, spdMax = 0.30;
      const baseR = 0.18, endR = 0.62;
      const thick = ()=>0.006 + 0.018*$resonance();

      let acc = solid(0,0,0,0);

      for(let i=0;i<n;i++){
        const t = n===1?0 : i/(n-1);
        const e = ()=>specAt(t);
        const fNoise = ()=> fMin + (fMax-fMin)*e();
        const sNoise = ()=> spdMin + (spdMax-spdMin)*e();
        const rot    = ()=> (0.01 + 0.10*$breath())*(t-0.5);
        const R = ()=> baseR + (endR-baseR)*t;
        const inner = ()=> Math.max(0.01, R() - thick());
        const smooth = ()=> 0.02 + 0.03*$resonance();

        const huePulse = ()=> 0.5 + 0.5*Math.sin(time*0.32 + t*5.4 + $H()*2.6);
        const cr = ()=> 0.22 + 0.70*(0.55*$L()  + 0.45*huePulse());
        const cg = ()=> 0.20 + 0.72*(0.55*$M1() + 0.45*(1-huePulse()));
        const cb = ()=> 0.24 + 0.74*(0.55*$M2() + 0.45*(0.5 + 0.5*Math.sin(time*0.46 + t*4.8 + $resonance()*2.1)));

        const ringBase =
          shape(96,R,smooth)
            .diff(shape(96,inner,smooth))
            .rotate(()=>time*rot())
            .modulate(noise(fNoise, sNoise), ()=> 0.015 + 0.090*$resonance())
            .modulateScale(noise(()=>0.8+0.6*fNoise(), ()=>0.4*sNoise()), ()=> 0.01 + 0.06*$breath())
            .brightness(()=> -0.12 + 0.24*e())
            .contrast(()=> 1.08 + 0.40*$resonance());

        const blendField =
          noise(
            () => 0.9 + 1.8*e(),
            () => 0.08 + 0.22*$breath() + 0.18*$H()
          )
            .color(
              () => 0.28 + 0.72*(0.5 + 0.5*Math.sin(time*0.32 + t*6.0 + $L()*2.4)),
              () => 0.24 + 0.76*(0.5 + 0.5*Math.sin(time*0.41 + t*4.6 + $M1()*2.2)),
              () => 0.30 + 0.70*(0.5 + 0.5*Math.sin(time*0.52 + t*5.2 + $M2()*2.4))
            )
            .brightness(()=> -0.35 + 0.28*e())
            .contrast(()=> 1.20 + 0.50*$resonance());

        const blendSoft =
          noise(
            () => 0.6 + 1.2*e(),
            () => 0.05 + 0.18*$breath()
          )
            .color(
              () => 0.45 + 0.55*$L(),
              () => 0.40 + 0.60*$M1(),
              () => 0.48 + 0.52*$H()
            )
            .brightness(()=> -0.42 + 0.30*$breath())
            .contrast(()=> 1.08 + 0.30*$resonance())
            .colorama(()=> 0.04 + 0.22*$H());

        const ringTex = ringBase
            .blend(blendField, ()=> 0.18 + 0.40*$resonance()*e())
            .mult(blendSoft,  ()=> 0.12 + 0.28*$breath())
            .color(cr, cg, cb)
            .saturate(()=> 1.00 + 0.45*$resonance())
            .brightness(()=> -0.08 + 0.18*e())
            .contrast(()=> 1.15 + 0.40*$resonance());

        acc = acc.add(ringTex, ()=>0.05 + 0.16*e());
      }

      return acc; // pas de multiplication avec cavité
    }

    // a.setResolution(4000,2000)

    /* ---- Composition ---- */
    ringsMulti(8)
      .scale(()=>0.5+0.05*$breath())
      .luma(()=>0.08+0.10*$H())
      .saturate(()=>1.0+0.4*$resonance())
      .out(o0);

    render(o0);

    /* ---- Ping au shell ---- */
    let hotSent=false,hotFrames=0;
    function hotLoop(){
      if(!hotSent){
        if(++hotFrames>=2){
          try{ window.parent.postMessage({type:'paint-hot'},'*'); }catch{}
          hotSent=true;
        }
      }
      requestAnimationFrame(hotLoop);
    }

    updateEnvelopes();
    hotLoop();
  </script>
</body>
</html>

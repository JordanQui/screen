<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Hydra • FM5 — Solid Bass (1 corde • highs deformation++)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#000000" />
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { position:fixed; inset:0; width:100vw; height:100vh; display:block; background:#000; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/hydra-synth/dist/hydra-synth.js"></script>
</head>
<body>
<canvas id="hydra"></canvas>
<script>
/* ====== Bands in (depuis le shell) ====== */
let low=0, mid1=0, mid2=0, high=0;
addEventListener('message',(e)=>{
  const d=e.data; if(!d) return;
  if(d.type==='bands'){ low=d.low||0; mid1=d.mid1||0; mid2=d.mid2||0; high=d.high||0; }
});

/* ====== Params exposés ====== */
window.P = {
  // Index FM (base)
  idx: { C1_M1:0.32, C1_M2:0.18, C4_M2:0.12, C4_NO:0.08, C5_M1:0.14, C5_M2:0.10 },

  // Mix
  mix: { C1:1.00, C2:0.80, C3:0.78, C4:0.78, C5:0.95 },

  // Couleurs
  col: {
    C1_min:[0.18,0.02,0.00], C1_add:[0.70,0.10,0.06],
    C2_min:[0.00,0.14,0.16], C2_add:[0.10,0.70,0.75],
    C3_min:[0.10,0.00,0.16], C3_add:[0.60,0.06,0.70],
    C4_min:[0.12,0.14,0.18], C4_add:[0.70,0.75,0.80],
    C5_min:[0.10,0.00,0.00], C5_add:[0.60,0.05,0.04]
  },

  // Masque “corde” (une seule ligne)
  maskY: 0.06,

  // Finition
  sat: 1.02, ctr: 1.012,

  // Flow anti-pixel
  flowBase: 0.005, flowL: 0.010, flowH: 0.016,

  // Feedback stabilisé (anti-flicker)
  fbMax: 0.22, fbBase: 0.08, fbL: 0.12, fbH: 0.08,

  // Sensibilité (conservée)
  sense: {
    gain:  { L:1.00, M1:1.15, M2:1.18, H:1.90 },
    gamma: { L:0.95, M1:0.90, M2:0.88, H:0.72 },
    w:     { L:0.15, M1:0.25, M2:0.25, H:0.60 },
    idxBoost: 3.90
  },

  // >>> Déformation pilotée par les aigus (intensité)
  def: {
    hiWarp:   0.26, // force de modulation par oscillateur
    hiNoise:  0.22, // force de modulation par bruit
    hiScroll: 0.07, // amplitude de glissement XY
    hiRotate: 0.12  // torsion (rotation modulée)
  }
};

/* ====== Hi-DPI + Hydra ====== */
const canvas = document.getElementById('hydra');
function setHiRes(){
  const dpr = Math.min(3.0, window.devicePixelRatio||1);
  const w = Math.floor(innerWidth*dpr), h = Math.floor(innerHeight*dpr);
  canvas.width=w; canvas.height=h;
  if (window.hydra?.setResolution) window.hydra.setResolution(w,h);
}
setHiRes();
const hydra = new Hydra({ canvas, detectAudio:false, width:canvas.width, height:canvas.height, pixelRatio:1 });
window.hydra = hydra;
addEventListener('resize', setHiRes);

/* ====== Aliases + courbes de sensibilité ====== */
const clamp01 = (x)=> Math.max(0, Math.min(1, x));
const L  = () => low;
const M1 = () => mid1;
const M2 = () => mid2;
const Hh = () => high;
const curve = (x, g, gam)=> clamp01(Math.pow(clamp01(x*g), gam));
const SL  = ()=> curve(L(),  P.sense.gain.L,  P.sense.gamma.L);
const SM1 = ()=> curve(M1(), P.sense.gain.M1, P.sense.gamma.M1);
const SM2 = ()=> curve(M2(), P.sense.gain.M2, P.sense.gamma.M2);
const SH  = ()=> curve(Hh(), P.sense.gain.H,  P.sense.gamma.H); // aigus boostés
const IDX_ENERGY = ()=> (SL()*P.sense.w.L + SM1()*P.sense.w.M1 + SM2()*P.sense.w.M2 + SH()*P.sense.w.H);

/* ====== Fréquences ====== */
const fLow  = () =>  8.0 + L()*18 + (L()*1.8)*Math.sin(time*1.05);
const fM1   = () => 10.0 + M1()* 8 + (M1()*1.6)*Math.sin(time*1.27);
const fM2   = () => 14.0 + M2()*10 + (M2()*2.0)*Math.sin(time*1.51);
const fHigh = () => Math.min(18 + (SH()*34) + (SH()*3.0)*Math.sin(time*2.18), 36);
const fSub  = () => Math.max(5.2, fLow()*0.66 + (L()*1.2 + (M1()+M2())*0.6)*0.45);

/* ====== Indices FM dynamiques ====== */
function boost(base, ownBand){
  const k = P.sense.idxBoost;
  const mult = 1 + k*(IDX_ENERGY()) + 0.35*SH();
  const own  = 1 + 0.5*ownBand();
  return base * mult * own;
}
const I = {
  C1_M1: () => 0.020 + boost(M1()*P.idx.C1_M1, SM1()),
  C1_M2: () => 0.012 + boost(M2()*P.idx.C1_M2, SM2()),
  C4_M2: () => 0.010 + boost(M2()*P.idx.C4_M2, SM2()) * (1.10 + 0.60*SH()),
  C4_NO: () => 0.006 + boost(SH()*P.idx.C4_NO, SH()) * (1.25 + 0.90*SH()),
  C5_M1: () => 0.008 + boost(M1()*P.idx.C5_M1, SM1()),
  C5_M2: () => 0.008 + boost(M2()*P.idx.C5_M2, SM2())
};

/* ====== Masque — une seule corde centrée ====== */
function stringMask(){
  return shape(4, 0.5, 0.001).scale(2.0, Math.max(0.01, P.maskY));
}

/* ====== Déformation Highs (pilotée par SH) ====== */
function deformHigh(src){
  // oscillateur de warp réactif aux aigus
  const warpOsc  = osc(() => 6 + SH()*18, 0, 0).rotate(() => SH()*P.def.hiRotate);
  const warpAmt  = () => P.def.hiWarp * (0.20 + SH()*1.20);
  const noiseTex = noise(() => 1.5 + SH()*6.0, () => 0.08 + SH()*0.38);
  const noiseAmt = () => P.def.hiNoise * (0.18 + SH()*1.10);
  const scr = () => SH()*P.def.hiScroll;

  return src
    .modulate(warpOsc,  warpAmt)
    .modulate(noiseTex, noiseAmt)
    .scrollX(() => scr()*Math.sin(time*(1.10 + SH()*3.0)))
    .scrollY(() => scr()*Math.cos(time*(0.90 + SH()*2.2)));
}

/* ====== Patch FM5 — Solid Bass (1 corde) ====== */
function buildPatch(){
  const mask = stringMask();
  const M_1 = osc(fM1, 0, 0);
  const M_2 = osc(fM2, 0, 0);

  // C1 — Bass carrier
  let C1 = osc(fLow, 0, 0)
    .modulate(M_1, I.C1_M1)
    .modulate(M_2, I.C1_M2)
    .mult(mask)
    .color(
      () => P.col.C1_min[0] + L()*P.col.C1_add[0],
      () => P.col.C1_min[1] + M1()*P.col.C1_add[1]*0.6,
      () => P.col.C1_min[2] + M2()*P.col.C1_add[2]*0.4
    );

  // C2 — Mid1 (cyan)
  let C2 = osc(fM1, 0, 0)
    .mult(mask)
    .color(
      () => P.col.C2_min[0] + M1()*P.col.C2_add[0],
      () => P.col.C2_min[1] + M1()*P.col.C2_add[1],
      () => P.col.C2_min[2] + M1()*P.col.C2_add[2]
    );

  // C3 — Mid2 (violet), léger push
  let C3 = osc(fM2, 0, 0)
    .modulate(M_1, () => 0.006 + M1()*0.040 * (1.0 + 0.3*SH()))
    .mult(mask)
    .color(
      () => P.col.C3_min[0] + M2()*P.col.C3_add[0],
      () => P.col.C3_min[1] + M2()*P.col.C3_add[1],
      () => P.col.C3_min[2] + M2()*P.col.C3_add[2]
    );

  // C4 — Highs glacés + déformation accentuée par SH
  let C4 = osc(fHigh, 0, 0)
    .modulate(M_2, I.C4_M2)
    .modulate(noise(2.2, 0.22), I.C4_NO)
    .mult(mask)
    .scale(2.5)
    .color(
      () => P.col.C4_min[0] + Math.min(1.0, SH()*P.col.C4_add[0]),
      () => P.col.C4_min[1] + Math.min(1.0, SH()*P.col.C4_add[1]),
      () => P.col.C4_min[2] + Math.min(1.0, SH()*P.col.C4_add[2])
    );
  C4 = deformHigh(C4); // <<< déformation aiguës

  // C5 — Sub
  let C5 = osc(fSub, 0, 0)
    .modulate(M_1, I.C5_M1)
    .modulate(M_2, I.C5_M2)
    .mult(mask)
    .color(
      () => P.col.C5_min[0] + L()*P.col.C5_add[0],
      () => P.col.C5_min[1] + M1()*P.col.C5_add[1]*0.5,
      () => P.col.C5_min[2] + M2()*P.col.C5_add[2]*0.4
    );

  // Somme
  let comp = C1
    .add(C2, P.mix.C2)
    .add(C3, P.mix.C3)
    .add(C4, P.mix.C4)
    .add(C5, P.mix.C5)
    .saturate(P.sat)
    .contrast(P.ctr)
    .modulate(o0, () => SH()*10);

  // Flow anti-pixel + anti-flicker
  const energy = () => L()+M1()+M2()+SH()*0.5;
  const flow = noise(() => 1.12 + energy()*1.2, () => 0.04 + SH()*0.26);
  comp = comp.modulate(flow, () => (energy()<0.10 ? 0.0 : (P.flowBase + (L()+M1()+M2())*P.flowL + SH()*P.flowH)));

  // Feedback propre
  const fbAmt = () => {
    const e = energy();
    const amt = P.fbBase + (L()+M1()+M2())*P.fbL + Math.max(0, SH()-0.15)*P.fbH;
    return Math.min(P.fbMax, e<0.10 ? 0.0 : amt);
  };
  comp.blend(src(o0).contrast(1.001), fbAmt).out(o0);
}
buildPatch();
render(o0);

/* ====== Ping orchestrateur ====== */
requestAnimationFrame(()=> parent.postMessage({type:'paint-hot'}, '*'));
</script>
</body>
</html>
